üìÅ Folder & File Structure Documentation
Your project uses a clean MVC (Model-View-Controller) inspired architecture for better separation of concerns, maintainability, and extensibility.

‚úÖ 1. main/app.js ‚Äì Application Entry Point (Controller Layer)
Purpose: Acts as the starting point of the application.

Responsibilities:
Imports configuration and sample data
Calls the allocation logic from the service layer
Passes the result to the view for display

Why: Keeps control logic centralized and manageable.

‚úÖ 2. services/discountService.js ‚Äì Business Logic (Model Layer)

Purpose: Core logic to allocate discounts among agents.

Responsibilities:
Normalize agent attributes
Calculate scores using weights
Allocate base and bonus amounts
Handle rounding edge cases and constraints (min/max)

Why: All core calculations are kept separate from the UI and data for clean logic flow.

‚úÖ 3. views/outputView.js ‚Äì Output Presentation (View Layer)

Purpose: Responsible for presenting the results.

Responsibilities:
Pretty print final allocations and summary
Format JSON output in a readable way

Why: Keeps output formatting cleanly separated from logic.

‚úÖ 4. data/sampleInput.js ‚Äì Sample Agent Data

Purpose: Provides input data (agents list with attributes).

Responsibilities:
Export sample agents with fields like id, performanceScore, targetAchievedPercent, etc.

Why: Helps with consistent testing and reproducibility.


‚úÖ 5. test/testCases.js ‚Äì Unit Testing File
Purpose: Validate the correctness of the allocation logic.

Responsibilities:
Contains 3 test cases:
Normal case
All-same values
Rounding edge case

Why:
Ensures reliability

Protects against regressions

üß† Justification for MVC Structure
Layer	                              Reason
Controller	                    Centralized control flow, keeps logic out of main file
Model (Service)              	Clean, modular business logic, easy to test and update
View	                        Isolated output formatting, reusable and changeable independently
Config	                        Decouples logic from values, allowing flexibility
Data/Test	                    Ensures consistent inputs and safe automated testing

